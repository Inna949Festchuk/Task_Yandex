# Дан массив неповторяющихся чисел, который был отсортирован, 
# а затем циклически сдвинут на неизвестное число позиций.
# Опишите без кода и псевдокода алгоритм поиска максимума в таком массиве
# Оцените сложность предложенного алгоритма
# Изменится ли сложность если массив содержит повторяющиеся числа?

def shift(lst, steps):
    # Циклический сдвиг https://younglinux.info/python/task/shift
    if steps < 0:
        steps = abs(steps)
        for i in range(steps):
            lst.append(lst.pop(0))
    else:
        for i in range(steps):
            lst.insert(0, lst.pop())
    # Поиск максимального (минимального) элемента в списке (бинарный (двоичный) поиск)
    # http://krivaksin.ru/python-rabota-so-spiskami-osnovnyie-algoritmyi-pri-rabote-so-spiskom/       
    sorted(lst) # Сортировка списка
    maximum = lst[0]
    for i in range(1, len(lst)):
        if lst[i] > maximum: # Заменить на <, при поиске минимума
            maximum = lst[i]
    return lst, maximum

nums = [9, 4, 4, 7, 4, 4, 8]
s = 0 
print(f'Исходный массив:\n {nums}',
      f'\nЦиклически сдвинутый на {s} позиции массив'
      f' и его максимум:\n {shift(nums, s)}')

# Оценка сложности алгоритма
# https://tproger.ru/articles/computational-complexity-explained/

# Ввод: Сортированный циклически сдвинутый массив  А
# Решение:
# Присвоить переменной М элемент массива (на позиции 0)
# Для позиции i массива в диапазоне от 0+1 до длины массива
#     Если i-тый элемент > М
#         Присвоить М этот i-ый элемент
# Возврат: М (максимум массива)
# O(log n) — логарифмическая сложность
# Если входной массив содержит повторяющиеся числа он не будет 
# сортированным, в таком случае его сложность изменится на линейную О(n)